#define _CRT_SECURE_NO_WARNINGS#include "draw.h"#include "input.h"#include "menu.h"#include "xor.hpp"#include <time.h>#include <dwmapi.h>#pragma comment(lib, "dwmapi")#include <process.h>#include <vector>#include "defs.h"#include "vectors.h"#include "sha_imp.h"#include <algorithm>HWND W = NULL;MSG M = { NULL };const MARGINS MG = { -1 ,-1, -1, -1 };RECT GR = { NULL };HWND GW = NULL;std::string ts[] = { xorstr_("Enemy"), xorstr_("All"), xorstr_("Bot") };std::string ls[] = { ("Off"), xorstr_("Top"), xorstr_("Middle"),xorstr_("Bottom") };std::string bs[] = { ("Off"), xorstr_("Corner"),xorstr_("2D"), xorstr_("3D") };std::string oO[] = { ("Off"), "On" };std::string aB[] = { xorstr_("Head"),xorstr_("Neck"), xorstr_("Body") };std::string aF[] = { "5", "10", "15", "20", "25", "30", "45", "60", "90", "120", "180" };std::string m[] = { "Off", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10" };std::string aT[] = { ("0"), "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20" };std::string k[] = { ("Capslock"), ("Alt"), ("LShift"), ("Fire"), "E", "F", "T", "V", "C", "X" };struct c {int a, r, g, b;c() = default;c(const int r, const int g, const int b, const int a = 255) : _c{ } {this->r = r;this->g = g;this->b = b;this->a = a;}explicit c(const uint32_t c) : _c{ } {this->a = c >> 24 & 0xff;this->r = c >> 16 & 0xff;this->g = c >> 8 & 0xff;this->b = c & 0xff;}static c from_uint(const uint32_t c) {return c(c);}unsigned char& operator[](const int i) {return _c[i];}template <typename T>c hsv_to_rgb(T h, T s, T v, const float alpha) const {int _r, _g, _b;if (s != 0) {h == 360 ? h = 0 : h = h / 60;auto i = static_cast<int>(trunc(h));int f = h - i;const int p = v * (1 - s);const int q = v * (1 - s * f);const int t = v * (1 - s * (1 - f));switch (i) {case 0:_r = v;_g = t;_b = p;break;case 1:_r = q;_g = v;_b = p;break;case 2:_r = p;_g = v;_b = t;break;case 3:_r = p;_g = q;_b = v;break;case 4:_r = t;_g = p;_b = v;break;default:_r = v;_g = p;_b = q;break;} } else {_r = v;_g = v;_b = v;}return c(static_cast<uint8_t>(_r * 255), static_cast<uint8_t>(_g * 255),static_cast<uint8_t>(_b * 255), alpha);}unsigned char _c[4];};void DS(int x, int y, DWORD c, const char* f, DWORD TRPE = DT_NOCLIP) {RECT FP = { x, y, x + 120, y + 20 };draw.font->DrawTextA(NULL, f, -1, &FP, TRPE, c);}void DR(float x, float y, float w, float h, D3DCOLOR c, IDirect3DDevice9Ex* p) {D3DRECT r = { x, y, x + w, y + h };p->Clear(1, &r, D3DCLEAR_TARGET, c, 0, 0);}void DB(float x, float y, float w, float h, float px, D3DCOLOR c, IDirect3DDevice9Ex* p) {DR(x, (y + h - px), w, px, c, p);DR(x, y, px, h, c, p);DR(x, y, w, px, c, p);DR((x + w - px), y, px, h, c, p);}void DCB(float x, float y, float w, float h, float bp, D3DCOLOR c, IDirect3DDevice9Ex* p) {DR(x + bp, y, w / 3, bp, c, p);DR(x + w - w / 3 + bp, y, w / 3, bp, c, p);DR(x, y, bp, h / 3, c, p);DR(x, y + h - h / 3 + bp * 2, bp, h / 3, c, p);DR(x + bp, y + h + bp, w / 3, bp, c, p);DR(x + w - w / 3 + bp, y + h + bp, w / 3, bp, c, p);DR(x + w + bp, y, bp, h / 3, c, p);DR(x + w + bp, y + h - h / 3 + bp * 2, bp, h / 3, c, p);}void DBX(int x, int y, int w, int h, D3DCOLOR BoxColor, D3DCOLOR BorderColor, IDirect3DDevice9Ex* p) {DR(x, y, w, h, BoxColor, p);DB(x, y, w, h, 1, BorderColor, p);}void DES(Vector3 H, Vector3 F, DWORD c, int rA) {Vector3 B = H - F;if (B.y < 0)B.y *= -1;int BW = (int)B.y / 2.4f;int DX = (int)H.x - (BW / 2);int DY = (int)H.y;DBX(DX, DY , BW + 1, (int)B.y + 5, D3DCOLOR_ARGB(10, 10, 0, 0), c, draw.GetDevice());}LPD3DXLINE x = NULL;void DL(float sX, float sY, float eX, float eY, D3DCOLOR c, float t) {x[0].SetWidth(t);x[0].SetGLLines(0);x[0].SetAntialias(1);D3DXVECTOR2 l[2];l[0].x = sX;l[0].y = sY;l[1].x = eX;l[1].y = eY;x[0].Begin();x[0].Draw(l, 2, c);x[0].End();}typedef LONG(WINAPI* rNtFC)(HANDLE, PVOID, ULONG);rNtFC nNtFC = NULL;typedef struct _PEB_LDR_DATA {UINT8 _PADDING_[12];LIST_ENTRY InLoadOrderModuleList;LIST_ENTRY InMemoryOrderModuleList;LIST_ENTRY InInitializationOrderModuleList;} PEB_LDR_DATA, * PPEB_LDR_DATA;typedef struct _PEB {#ifdef _WIN64 UINT8 _PADDING_[24];#else UINT8 _PADDING_[12];#endif PEB_LDR_DATA* Ldr;} PEB, * PPEB;typedef struct _LDR_DATA_TABLE_ENTRY {LIST_ENTRY InLoadOrderLinks;LIST_ENTRY InMemoryOrderLinks;LIST_ENTRY InInitializationOrderLinks;VOID* DllBase;} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;typedef struct _UNLINKED_MODULE{HMODULE hModule;PLIST_ENTRY RealInLoadOrderLinks;PLIST_ENTRY RealInMemoryOrderLinks;PLIST_ENTRY RealInInitializationOrderLinks;PLDR_DATA_TABLE_ENTRY Entry;} UNLINKED_MODULE;#define UNLINK(x)	(x).Flink->Blink = (x).Blink;	(x).Blink->Flink = (x).Flink;#define RELINK(x, real)	(x).Flink->Blink = (real);	(x).Blink->Flink = (real);	(real)->Blink = (x).Blink;	(real)->Flink = (x).Flink;std::vector<UNLINKED_MODULE> UL;struct FMH{HMODULE m_hModule;FMH(HMODULE h) : m_hModule(h){}bool operator() (UNLINKED_MODULE const& M) const {return (M.hModule == m_hModule);}};void RMT(HMODULE h) {std::vector<UNLINKED_MODULE>::iterator it = std::find_if(UL.begin(), UL.end(), FMH(h));if (it == UL.end()) {return;}RELINK((*it).Entry->InLoadOrderLinks, (*it).RealInLoadOrderLinks);RELINK((*it).Entry->InInitializationOrderLinks, (*it).RealInInitializationOrderLinks);RELINK((*it).Entry->InMemoryOrderLinks, (*it).RealInMemoryOrderLinks);UL.erase(it);}void UMT(HMODULE h) {std::vector<UNLINKED_MODULE>::iterator it = std::find_if(UL.begin(), UL.end(), FMH(h));if (it != UL.end()) {return;}#ifdef _WIN64 PPEB p = (PPEB)__readgsqword(0x60);#else PPEB p = (PPEB)__readfsdword(0x30);#endif PLIST_ENTRY E = p->Ldr->InLoadOrderModuleList.Flink;PLDR_DATA_TABLE_ENTRY C = NULL;while (E != &p->Ldr->InLoadOrderModuleList && E != NULL) {C = CONTAINING_RECORD(E, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);if (C->DllBase == h) {UNLINKED_MODULE M = { 0 };M.hModule = h;M.RealInLoadOrderLinks = C->InLoadOrderLinks.Blink->Flink;M.RealInInitializationOrderLinks = C->InInitializationOrderLinks.Blink->Flink;M.RealInMemoryOrderLinks = C->InMemoryOrderLinks.Blink->Flink;M.Entry = C;UL.push_back(M);UNLINK(C->InLoadOrderLinks);UNLINK(C->InInitializationOrderLinks);UNLINK(C->InMemoryOrderLinks);break;}E = E->Flink;}void HideThread(HANDLE h) {typedef NTSTATUS(NTAPI* pNtSIT)(HANDLE, UINT, PVOID, ULONG);NTSTATUS S;pNtSIT NtSIT = (pNtSIT)GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")),"NtSetInformationThread");if (NtSIT == NULL)return false;if (h == NULL)S = NtSIT(GetCurrentThread(),0x11,0,0);else S = NtSIT(h, 0x11, 0, 0);if (S != 0x00000000)return false;else return true;}
