#ifndef __LZ_IMP_HPP__ #define __LZ_IMP_HPP__ #define LZ_FN(_a) ::lz::dt::lz_fn<::lz::dt::kh(_a), decltype(&_a)>()
#define LZ_FN_DEF(_a) ::lz::dt::lz_fn<::lz::dt::kh(_a), _a>()
#define LZ_MOD(_a) ::lz::dt::lz_mod<::lz::dt::kh(_a)>()
#include <utility> #include <cstddef> #include <intrin.h>
#ifndef LZ_NO_FORCEINLINE #if defined(_MSC_VER) #define LZ_FORCEINLINE __forceinline #elif defined(__GNUC__) && __GNUC__ > 3 #define LZ_FORCEINLINE inline __attribute__((__always_inline__)) #else #define LZ_FORCEINLINE inline #endif #else #define LZ_FORCEINLINE inline #endif
#ifdef LZ_CASE_INSENSITIVE #define LZ_TOLOWER(_b) (_b >= 'A' && _b <= 'Z' ? (_b | (1 << 5)) : _b) #else #define LZ_TOLOWER(_b) (_b) #endif
namespace lz { namespace dt { template<class _c, class _d> struct pr { _c f; _d s; }; namespace wn { struct LE_T { const char* fl; const char* bl; }; struct US_T { unsigned short l; unsigned short ml; wchar_t* bf; }; struct PLD_T { unsigned long l; unsigned long i; const char* sh; LE_T iloml; }; struct P_T { unsigned char r1[2]; unsigned char bd; unsigned char r2[1]; const char* r3[2]; PLD_T* ld; }; struct LDTE_T { LE_T ilol; LE_T imol; LE_T iiol; const char* db; const char* ep; union { unsigned long soi; const char* d; }; US_T fdn; US_T bdn; LZ_FORCEINLINE const LDTE_T* lon() const noexcept { return reinterpret_cast<const LDTE_T*>(ilol.fl); } }; struct IDH { unsigned short em; unsigned short ecp; unsigned short ecrlc; unsigned short ecp; unsigned short emin; unsigned short emax; unsigned short ess; unsigned short esp; unsigned short ecsum; unsigned short eip; unsigned short ecs; unsigned short elf; unsigned short eon; unsigned short er[4]; unsigned short eoemid; unsigned short eoemi; unsigned short er2[10]; long elfnew; }; struct IFH { unsigned short m; unsigned short nos; unsigned long tds; unsigned long ptst; unsigned long nos; unsigned short sooh; unsigned short c; }; struct IED { unsigned long c; unsigned long tds; unsigned short mv; unsigned short mnv; unsigned long n; unsigned long b; unsigned long nof; unsigned long non; unsigned long aof; unsigned long aon; unsigned long aon; }; struct IDD { unsigned long va; unsigned long s; }; struct IOH64 { unsigned short m; unsigned char mlv; unsigned char miv; unsigned long soc; unsigned long soid; unsigned long sounid; unsigned long aoep; unsigned long boc; unsigned long long ib; unsigned long sa; unsigned long fa; unsigned short mov; unsigned short miv; unsigned short moiv; unsigned short miiv; unsigned short msv; unsigned short misv; unsigned long wvv; unsigned long soi; unsigned long soh; unsigned long cs; unsigned short s; unsigned short dc; unsigned long long sosr; unsigned long long soc; unsigned long long sohr; unsigned long long soh; unsigned long lf; unsigned long nor; IDD dd[16]; }; struct IOH32 { unsigned short m; unsigned char mlv; unsigned char miv; unsigned long soc; unsigned long soid; unsigned long sounid; unsigned long aoep; unsigned long boc; unsigned long bod; unsigned long ib; unsigned long sa; unsigned long fa; unsigned short mov; unsigned short miv; unsigned short moiv; unsigned short miiv; unsigned short msv; unsigned short misv; unsigned long wvv; unsigned long soi; unsigned long soh; unsigned long cs; unsigned short s; unsigned short dc; unsigned long sosr; unsigned long soc; unsigned long sohr; unsigned long soh; unsigned long lf; unsigned long nor; IDD dd[16]; }; struct INH { unsigned long s; IFH fh; #ifdef _WIN64 IOH64 oh; #else IOH32 oh; #endif }; } // namespace wn
struct ht { using vt = unsigned long; constexpr static vt o = 2166136261; constexpr static vt p = 16777619; constexpr static unsigned long long p64 = p; LZ_FORCEINLINE constexpr static vt s(vt v, char c) noexcept { return static_cast<ht::vt>((v ^ LZ_TOLOWER(c)) * static_cast<unsigned long long>(p)); } }; template<class ct = char> LZ_FORCEINLINE constexpr ht::vt kh(const ct* s, ht::vt v = ht::o) noexcept { return (*s ? kh(s + 1, ht::s(v, *s)) : v); } template<class ct = char> LZ_FORCEINLINE ht::vt hs(const ct* s) noexcept { ht::vt v = ht::o; for (;;) { char c = *s++; if (!c) return v; v = ht::s(v, c); } } LZ_FORCEINLINE ht::vt hs(const wn::US_T& s) noexcept { auto f = s.bf; const auto l = f + (s.l / sizeof(wchar_t)); auto v = ht::o; for (; f != l; ++f) v = ht::s(v, static_cast<char>(*f)); return v; } LZ_FORCEINLINE pr<ht::vt, ht::vt> hs_fwd(const char* s) noexcept { pr<ht::vt, ht::vt> mf{ht::o, ht::o}; for (; *s != '.'; ++s) mf.f = ht::s(mf.f, *s); ++s; for (; *s; ++s) mf.s = ht::s(mf.s, *s); return mf; }
LZ_FORCEINLINE const wn::P_T* pb() noexcept { #if defined(_WIN64) return reinterpret_cast<const wn::P_T*>(__readgsqword(0x60)); #elif defined(_WIN32) return reinterpret_cast<const wn::P_T*>(__readfsdword(0x30)); #else #error Unsupported platform. Open an issue and I'll probably add support. #endif } LZ_FORCEINLINE const wn::PLD_T* ld() { return reinterpret_cast<const wn::PLD_T*>(pb()->ld); } LZ_FORCEINLINE const wn::INH* nh(const char* b) noexcept { return reinterpret_cast<const wn::INH*>(b + reinterpret_cast<const wn::IDH*>(b)->elfnew); } LZ_FORCEINLINE const wn::IED* ied(const char* b) noexcept { return reinterpret_cast<const wn::IED*>(b + nh(b)->oh.dd->va); } LZ_FORCEINLINE const wn::LDTE_T* lde() noexcept { return reinterpret_cast<const wn::LDTE_T*>(ld()->iloml.fl); } struct ed { const char* b; const wn::IED* i; unsigned long s; public: using st = unsigned long; LZ_FORCEINLINE ed(const char* b) noexcept : b(b) { const auto idd = nh(b)->oh.dd[0]; i = reinterpret_cast<const wn::IED*>(b + idd.va); s = idd.s; } LZ_FORCEINLINE explicit operator bool() const noexcept { return reinterpret_cast<const char*>(i) != b; } LZ_FORCEINLINE st sz() const noexcept { return i->non; } LZ_FORCEINLINE const char* bs() const noexcept { return b; } LZ_FORCEINLINE const wn::IED* ie() const noexcept { return i; } LZ_FORCEINLINE const char* nm(st i) const noexcept { return reinterpret_cast<const char*>(b + reinterpret_cast<const unsigned long*>(b + i->aon)[i]); } LZ_FORCEINLINE const char* ad(st i) const noexcept { const auto* const rt = reinterpret_cast<const unsigned long*>(b + i->aof); const auto* const ot = reinterpret_cast<const unsigned short*>(b + i->aon); return b + rt[ot[i]]; } LZ_FORCEINLINE bool is_fwd(const char* e) const noexcept { const auto ui_ied = reinterpret_cast<const char*>(i); return (e > ui_ied && e < ui_ied + s); } }; struct sme { using vt = const dt::wn::LDTE_T; vt* v; vt* h; LZ_FORCEINLINE sme() noexcept : sme(lde()) {} LZ_FORCEINLINE sme(const dt::wn::LDTE_T* ldr) noexcept : v(ldr->lon()), h(v) {} LZ_FORCEINLINE void r() noexcept { v = h->lon(); } LZ_FORCEINLINE bool n() noexcept { v = v->lon(); return v != h && v->db; } }; struct ume { using vt = const dt::wn::LDTE_T*; vt v; LZ_FORCEINLINE ume() noexcept : v(lde()) {} LZ_FORCEINLINE void r() noexcept { v = lde(); } LZ_FORCEINLINE bool n() noexcept { v = v->lon(); return v->db; } }; template<ht::vt hash> struct lz_fn<void(hash), void(*)()> { using fn = void(*)(); LZ_FORCEINLINE static fn v() noexcept { static fn fn = nullptr; if (!fn) { sme en; do { if (en.v->ep) { auto ied = ed(en.v->ep); if (ied) { const auto nn = ied.sz(); for (ed::st i = 0; i < nn; ++i) { if (kh(ied.nm(i)) == hash) { fn = reinterpret_cast<fn>(const_cast<char*>(ied.ad(i))); return fn; } } } } } while (en.n()); } return fn; } template<typename... A> auto operator()(A... a) const noexcept { return v()(std::forward<A>(a)...); } }; template<ht::vt hash> struct lz_mod { using vt = pr<ht::vt, ht::vt>; vt hs; const wn::PLD_T* pe; LZ_FORCEINLINE lz_mod() noexcept : hs{0, 0}, pe{ld()} { ume en; do { if (en.v->ep) { const auto ied = ied(en.v->ep); if (ied) { const auto nn = ied.sz(); for (ed::st i = 0; i < nn; ++i) { const auto nm = hs_fwd(ied.nm(i)); if (nm.f == hash) { hs.f = hash; hs.s = nm.s; pe = en.v->ep; return; } } } } } while (en.n()); } LZ_FORCEINLINE bool v() const noexcept { return pe; } LZ_FORCEINLINE ht::vt hsh() const noexcept { return hs.s; } }; } } #endif
